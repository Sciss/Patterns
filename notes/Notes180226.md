# Interference of fold-left and flow

Consider the following example:

    val plain = (1 to 2).flatMap { _ =>
      val xs  = Seq(Seq(1), Seq(2, 3))
      val xsi = xs.indices.iterator
      xs.foldLeft(Seq[Int]()) { (accum, x) =>
        val a = xsi.next()
        val z = x.map { y =>
          y + a
        }
        accum ++ z
      }
    }

    val pat: Pat[Int] = Graph {                 // level 1
      Pat.loop(2) {                             // level 2
        val xs  = Pat(Pat(1), Pat(2, 3))
        val xsi = xs.indices.flow()
        xs.foldLeft(Pat[Int]()) { (accum, x) => // level 3
          val a = xsi.hold()
          val z = x.bubble.flatMap { y =>       // level 4
            y + a
          }
          accum ++ z
        }
      }
    }
    
The expected result is `Seq(1, 3, 4, 1, 3, 4)`, but the actual result (as of this writing)
is `Seq(1, 2, 4, 1, 2, 4)`. Why is this so? The reason is the duplicate expansion of `xsi`
after the re-writing of the fold-left, from

    FoldLeft(
      outer     = Pat(Pat(1), Pat(2, 3)),
      z         = Pat(),
      itIn      = It(1),
      itCarry   = It(2),
      inner = Cat(
        It(2),
        FlatMap(
          outer = Grouped(It(1),1),
          it    = It(3),
          inner = BinaryOp(Plus,It(3),
            Hold(Flow(Indices(Pat(Pat(1), Pat(2, 3))), level = 2), true)),
          innerLevel = 4)
      )
    )

to a fold-left with a new inner value of

    Cat(
      Cat(
        Pat(),
        FlatMap(
          outer = Grouped(Pat(1),1),
          it    = It(1000000001),
          inner = BinaryOp(Plus,It(1000000001),
            Hold(Flow(Indices(Pat(Pat(1), Pat(2, 3))), level = 2), true)),
          innerLevel = 4)
      ),
      FlatMap(
        outer = Grouped(Pat(2, 3),1),
        it    = It(1000000002),
        inner = BinaryOp(Plus,It(1000000002),
          Hold(Flow(Indices(Pat(Pat(1), Pat(2, 3))), level = 2),true)),
        innerLevel = 4)
    )

(An even more complicated case would be another `Pat.loop(2)` around the `foldLeft` call.)

Two things:

- the `Flow` must not be duplicated; or more precisely, the pattern may be duplicated,
  but the expansion of the stream must not be duplicated; a first attempt might be to
  assign it a uniqueID obtained from the graph builder
- the outer `Cat` iteration must ensure that the order of the polling of the flow stream
  is correct. This was not a problem before, as the streams came from purely functional
  patterns and could simply be duplicated.
  
Let's look at the second issue. According to the above expansion,
the most likely branch to pull first (N.B. probably through `hasNext`) is the one 
using `Pat(1)`, i.e. the first iteration of `foldLeft`.

What if we had `z ++ accum` instead of `accum ++ z`?

    Cat(
      FlatMap(
        outer = Grouped(Pat(2, 3),1),
        it    = It(1000000001),
        inner = BinaryOp(Plus,It(1000000001),
          Hold(Flow(Indices(Pat(Pat(1), Pat(2, 3))),2),true)),
        innerLevel = 4),
      Cat(
        FlatMap(
          outer = Grouped(Pat(1),1),
          it    = It(1000000002),
          inner = BinaryOp(Plus,It(1000000002),
            Hold(Flow(Indices(Pat(Pat(1), Pat(2, 3))),2),true)),
          innerLevel = 4),
        Pat()
      )
    )
    
Now the branch to pull first most likely is the one using `Pat(2, 3)`.
While the rewriting was fine from a purely functional point of view,
it is now infected by the assumed iteration (execution) logic of `foldLeft`...
We have a conflict between pull (functional) and push (imperative) models
it seems.
