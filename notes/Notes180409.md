# Serialization and Stream-Provider

For example, `FlatMap`:

    private def mkItStream(implicit tx: S#Tx) = {
      val res = new MapItStream(outer, tx)
      ctx.addStream(ref, res)
      res
    }

    ctx.provideOuterStream(it.token, mkItStream(_))(tx0)

    def reset()(implicit tx: S#Tx): Unit = {
      ctx.getStreams(ref).foreach {
        case m: MapItStream[S, _] => m.resetOuter()
      }
      innerStream.reset()
    }

    private def advance()(implicit tx: S#Tx): Unit = {
      ctx.getStreams(ref).foreach {
        case m: MapItStream[S, _] => m.advance()
      }
      innerStream.reset()
    }

When could this be a problem?

It appears that we should simply save the streams with the parent stream instead of the context.
Since `MapItStream` and others will expand other streams in each iteration, it will be important to consider
the correct `dispose()` calls, in order not to "leak memory";
first, by making sure those calls are issued whenever we update an `S#Var[Stream[A, _]]`.
We might not need an observation of the disposal, since only `It`-streams will be registered with their parents.
Where `ItImpl.expand` is a simple case, calling explicitly into `mkOuterStream`, it's unclear how to solve this
in deserialization. Also, `dispose` does not (currently) have a `Context` reference.

A simple method - although perhaps not the most efficient - is to require that `Stream.serializer` obtains
an implicit `Context`. (In fact, `Context` could hold that serializer!) Then `readIdentified` could access the
context, and obtain the parent stream? (This would cause problems with `PatElem` serializer... NOT. There is no
stream support there?)

## Therefore

We qualify `It`-stream implementations by always carrying the `Context` as constructor argument, so we can stick
to plain `stm.Disposable`. The `dispose` method would unregister the stream from the parent stream.

## Weirdness

So, 'lambda'-patterns should anyway never be stored in a (hypothetical) `StreamObj`, because it simply doesn't make
sense that they exist in a vacuum with orphaned `It` references!

That could mean that we will never deserialize a lambda from a place that does not go through the outer pattern/stream,
such as `FlatMap`. So where would `MapItStream` in this case require deserialization? The state of `FlatMap`.stream
contains

    val innerStream: Stream[S, A]
    val itStream: MapItStream[S, A]   // only to ensure we have _one_ instance at least
    
Here, `innerStream` is annoying, because it will serialize its own map-it-streams. Also note that `innerStream`
currently is in the careful position of following `provideOuterStream`.

Is `StreamObj` not a boundary, at which _some state_ of `Context` should be serialized? After all, we can't mix
RNG seeds and it-counters for token allocation? So `StreamObj` would "set" or "use" it's own context, which would
ensure that successive expansions are well behaved. This is why requiring `Context` for `Stream.serializer` is
not a big problem.